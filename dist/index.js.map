{"version":3,"sources":["../src/services/speech.ts","../src/services/audioUtils.ts","../src/services/transcription.ts","../src/index.ts"],"sourcesContent":["import { PassThrough } from 'stream';\nimport { Readable } from 'node:stream';\nimport { ReadableStream } from 'node:stream/web';\nimport { IAgentRuntime, ISpeechService, ServiceType } from '@elizaos/core';\nimport { getWavHeader } from './audioUtils.js';\nimport { Service } from '@elizaos/core';\n// import { validateNodeConfig } from '../environment.js';\nimport * as Echogarden from 'echogarden';\nimport { elizaLogger } from '@elizaos/core';\n\nfunction prependWavHeader(\n  readable: Readable,\n  audioLength: number,\n  sampleRate: number,\n  channelCount: number = 1,\n  bitsPerSample: number = 16,\n): Readable {\n  const wavHeader = getWavHeader(\n    audioLength,\n    sampleRate,\n    channelCount,\n    bitsPerSample,\n  );\n  let pushedHeader = false;\n  const passThrough = new PassThrough();\n  readable.on('data', function (data) {\n    if (!pushedHeader) {\n      passThrough.push(wavHeader);\n      pushedHeader = true;\n    }\n    passThrough.push(data);\n  });\n  readable.on('end', function () {\n    passThrough.end();\n  });\n  return passThrough;\n}\n\nasync function getVoiceSettings(runtime: IAgentRuntime) {\n  const hasElevenLabs = !!runtime.getSetting('ELEVENLABS_XI_API_KEY');\n  const useVits = !hasElevenLabs;\n\n  // Get voice settings from character card\n  const vitsSettings = runtime.character.settings?.voice;\n  const elevenlabsSettings = runtime.character.settings?.voice?.elevenlabs;\n\n  elizaLogger.log('Voice settings:', {\n    hasElevenLabs,\n    useVits,\n    vitsSettings,\n    elevenlabsSettings,\n  });\n\n  return {\n    elevenlabsVoiceId:\n      elevenlabsSettings?.voiceId ||\n      runtime.getSetting('ELEVENLABS_VOICE_ID') ||\n      '21m00Tcm4TlvDq8ikWAM',\n    elevenlabsModel:\n      elevenlabsSettings?.model ||\n      runtime.getSetting('ELEVENLABS_MODEL_ID') ||\n      'eleven_multilingual_v2',\n    elevenlabsStability:\n      elevenlabsSettings?.stability ||\n      runtime.getSetting('ELEVENLABS_VOICE_STABILITY') ||\n      '0.5',\n    elevenlabsStreamingLatency:\n      runtime.getSetting('ELEVENLABS_OPTIMIZE_STREAMING_LATENCY') || '4',\n    elevenlabsOutputFormat:\n      runtime.getSetting('ELEVENLABS_OUTPUT_FORMAT') || 'pcm_16000',\n    elevenlabsSimilarity:\n      runtime.getSetting('ELEVENLABS_VOICE_SIMILARITY_BOOST') || '0.9',\n    elevenlabsStyle: runtime.getSetting('ELEVENLABS_VOICE_STYLE') || '0.66',\n    elevenlabsSpeakerBoost:\n      runtime.getSetting('ELEVENLABS_VOICE_USE_SPEAKER_BOOST') || 'false',\n    vitsVoice:\n      vitsSettings?.model ||\n      vitsSettings?.url ||\n      runtime.getSetting('VITS_VOICE') ||\n      'en_US-hfc_female-medium',\n    elevenlabsUrl:\n      runtime.getSetting('ELEVENLABS_XI_API_URL') ||\n      'https://api.elevenlabs.io/v1',\n    useVits,\n  };\n}\n\nasync function textToSpeech(runtime: IAgentRuntime, text: string) {\n  // await validateNodeConfig(runtime);\n  const {\n    elevenlabsVoiceId,\n    elevenlabsModel,\n    elevenlabsUrl,\n    elevenlabsStreamingLatency,\n    elevenlabsOutputFormat,\n    elevenlabsSimilarity,\n    elevenlabsStability,\n    elevenlabsStyle,\n    elevenlabsSpeakerBoost,\n  } = await getVoiceSettings(runtime);\n\n  try {\n    elizaLogger.log('sending request to Eleven Labs API');\n    elizaLogger.log('Eleven Labs voice ID:', elevenlabsVoiceId);\n    elizaLogger.log('Eleven Labs model ID:', elevenlabsModel);\n    elizaLogger.log(\n      'Eleven Labs streaming latency:',\n      elevenlabsStreamingLatency,\n    );\n    elizaLogger.log('Eleven Labs output format:', elevenlabsOutputFormat);\n    elizaLogger.log('Eleven Labs similarity boost:', elevenlabsSimilarity);\n    elizaLogger.log('Eleven Labs stability:', elevenlabsStability);\n    elizaLogger.log('Eleven Labs style:', elevenlabsStyle);\n    elizaLogger.log('Eleven Labs speaker boost:', elevenlabsSpeakerBoost);\n\n    const response = await fetch(\n      `${elevenlabsUrl}/text-to-speech/${elevenlabsVoiceId}/stream?optimize_streaming_latency=${elevenlabsStreamingLatency}&output_format=${elevenlabsOutputFormat}`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'xi-api-key': runtime.getSetting('ELEVENLABS_XI_API_KEY'),\n        },\n        body: JSON.stringify({\n          model_id: elevenlabsModel,\n          text: text,\n          voice_settings: {\n            similarity_boost: elevenlabsSimilarity,\n            stability: elevenlabsStability,\n            style: elevenlabsStyle,\n            use_speaker_boost: elevenlabsSpeakerBoost,\n          },\n        }),\n      },\n    );\n\n    const status = response.status;\n    if (status != 200) {\n      const errorBodyString = await response.text();\n      const errorBody = JSON.parse(errorBodyString);\n\n      // Check for quota exceeded error\n      if (status === 401 && errorBody.detail?.status === 'quota_exceeded') {\n        elizaLogger.log('ElevenLabs quota exceeded, falling back to VITS');\n        throw new Error('QUOTA_EXCEEDED');\n      }\n\n      throw new Error(\n        `Received status ${status} from Eleven Labs API: ${errorBodyString}`,\n      );\n    }\n\n    if (response) {\n      const webStream = ReadableStream.from(response.body as ReadableStream);\n      const reader = webStream.getReader();\n\n      const readable = new Readable({\n        read() {\n          reader.read().then(({ done, value }) => {\n            if (done) {\n              this.push(null);\n            } else {\n              this.push(value);\n            }\n          });\n        },\n      });\n\n      if (elevenlabsOutputFormat.startsWith('pcm_')) {\n        const sampleRate = parseInt(elevenlabsOutputFormat.substring(4));\n        const withHeader = prependWavHeader(\n          readable,\n          1024 * 1024 * 100,\n          sampleRate,\n          1,\n          16,\n        );\n        return withHeader;\n      } else {\n        return readable;\n      }\n    } else {\n      return new Readable({\n        read() {},\n      });\n    }\n  } catch (error) {\n    if (error.message === 'QUOTA_EXCEEDED') {\n      // Fall back to VITS\n      const { vitsVoice } = await getVoiceSettings(runtime);\n      const { audio } = await Echogarden.synthesize(text, {\n        engine: 'vits',\n        voice: vitsVoice,\n      });\n\n      let wavStream: Readable;\n      if (audio instanceof Buffer) {\n        elizaLogger.log('audio is a buffer');\n        wavStream = Readable.from(audio);\n      } else if ('audioChannels' in audio && 'sampleRate' in audio) {\n        elizaLogger.log('audio is a RawAudio');\n        const floatBuffer = Buffer.from(audio.audioChannels[0].buffer);\n        elizaLogger.log('buffer length: ', floatBuffer.length);\n\n        // Get the sample rate from the RawAudio object\n        const sampleRate = audio.sampleRate;\n\n        // Create a Float32Array view of the floatBuffer\n        const floatArray = new Float32Array(floatBuffer.buffer);\n\n        // Convert 32-bit float audio to 16-bit PCM\n        const pcmBuffer = new Int16Array(floatArray.length);\n        for (let i = 0; i < floatArray.length; i++) {\n          pcmBuffer[i] = Math.round(floatArray[i] * 32767);\n        }\n\n        // Prepend WAV header to the buffer\n        const wavHeaderBuffer = getWavHeader(\n          pcmBuffer.length * 2,\n          sampleRate,\n          1,\n          16,\n        );\n        const wavBuffer = Buffer.concat([\n          wavHeaderBuffer,\n          Buffer.from(pcmBuffer.buffer),\n        ]);\n\n        wavStream = Readable.from(wavBuffer);\n      } else {\n        throw new Error('Unsupported audio format');\n      }\n      return wavStream;\n    }\n    throw error; // Re-throw other errors\n  }\n}\n\nasync function processVitsAudio(audio: any): Promise<Readable> {\n  let wavStream: Readable;\n  if (audio instanceof Buffer) {\n    elizaLogger.log('audio is a buffer');\n    wavStream = Readable.from(audio);\n  } else if ('audioChannels' in audio && 'sampleRate' in audio) {\n    elizaLogger.log('audio is a RawAudio');\n    const floatBuffer = Buffer.from(audio.audioChannels[0].buffer);\n    elizaLogger.log('buffer length: ', floatBuffer.length);\n\n    const sampleRate = audio.sampleRate;\n    const floatArray = new Float32Array(floatBuffer.buffer);\n    const pcmBuffer = new Int16Array(floatArray.length);\n\n    for (let i = 0; i < floatArray.length; i++) {\n      pcmBuffer[i] = Math.round(floatArray[i] * 32767);\n    }\n\n    const wavHeaderBuffer = getWavHeader(\n      pcmBuffer.length * 2,\n      sampleRate,\n      1,\n      16,\n    );\n    const wavBuffer = Buffer.concat([\n      wavHeaderBuffer,\n      Buffer.from(pcmBuffer.buffer),\n    ]);\n    wavStream = Readable.from(wavBuffer);\n  } else {\n    throw new Error('Unsupported audio format');\n  }\n  return wavStream;\n}\n\nasync function generateVitsAudio(\n  runtime: IAgentRuntime,\n  text: string,\n): Promise<Readable> {\n  const { vitsVoice } = await getVoiceSettings(runtime);\n  const { audio } = await Echogarden.synthesize(text, {\n    engine: 'vits',\n    voice: vitsVoice,\n  });\n  return processVitsAudio(audio);\n}\n\nexport class SpeechService extends Service implements ISpeechService {\n  static serviceType: ServiceType = ServiceType.SPEECH_GENERATION;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async initialize(_runtime: IAgentRuntime): Promise<void> {}\n\n  getInstance(): ISpeechService {\n    return SpeechService.getInstance();\n  }\n\n  async generate(runtime: IAgentRuntime, text: string): Promise<Readable> {\n    try {\n      elizaLogger.log('Generating speech for text:', text);\n      const { useVits } = await getVoiceSettings(runtime);\n\n      if (useVits || !runtime.getSetting('ELEVENLABS_XI_API_KEY')) {\n        return await generateVitsAudio(runtime, text);\n      }\n\n      return await textToSpeech(runtime, text);\n    } catch (error) {\n      console.error('Speech generation error:', error);\n      return await generateVitsAudio(runtime, text);\n    }\n  }\n}\n","export function getWavHeader(\n  audioLength: number,\n  sampleRate: number,\n  channelCount: number = 1,\n  bitsPerSample: number = 16,\n): Buffer {\n  const wavHeader = Buffer.alloc(44);\n  wavHeader.write('RIFF', 0);\n  wavHeader.writeUInt32LE(36 + audioLength, 4); // Length of entire file in bytes minus 8\n  wavHeader.write('WAVE', 8);\n  wavHeader.write('fmt ', 12);\n  wavHeader.writeUInt32LE(16, 16); // Length of format data\n  wavHeader.writeUInt16LE(1, 20); // Type of format (1 is PCM)\n  wavHeader.writeUInt16LE(channelCount, 22); // Number of channels\n  wavHeader.writeUInt32LE(sampleRate, 24); // Sample rate\n  wavHeader.writeUInt32LE((sampleRate * bitsPerSample * channelCount) / 8, 28); // Byte rate\n  wavHeader.writeUInt16LE((bitsPerSample * channelCount) / 8, 32); // Block align ((BitsPerSample * Channels) / 8)\n  wavHeader.writeUInt16LE(bitsPerSample, 34); // Bits per sample\n  wavHeader.write('data', 36); // Data chunk header\n  wavHeader.writeUInt32LE(audioLength, 40); // Data chunk size\n  return wavHeader;\n}\n","import {\n  elizaLogger,\n  IAgentRuntime,\n  ITranscriptionService,\n  settings,\n  TranscriptionProvider,\n} from '@elizaos/core';\nimport { Service, ServiceType } from '@elizaos/core';\nimport { exec } from 'child_process';\nimport { File } from 'formdata-node';\nimport fs from 'fs';\nimport { nodewhisper } from 'nodejs-whisper';\nimport OpenAI from 'openai'; // todo, can probably move this to model provider or whateer\nimport os from 'os';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { promisify } from 'util';\nimport { createClient, DeepgramClient } from '@deepgram/sdk';\nimport { TranscriptionOptions } from './transcriptionOptions';\n\n// const __dirname = path.dirname(new URL(import.meta.url).pathname); #compatibility issues with windows\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst execAsync = promisify(exec);\n\nexport class TranscriptionService\n  extends Service\n  implements ITranscriptionService\n{\n  private runtime: IAgentRuntime | null = null;\n  static serviceType: ServiceType = ServiceType.TRANSCRIPTION;\n  private CONTENT_CACHE_DIR: string;\n  private DEBUG_AUDIO_DIR: string;\n  private TARGET_SAMPLE_RATE = 16000; // Common sample rate for speech recognition\n  private isCudaAvailable: boolean = false;\n\n  /**\n   * CHANGED: We now use TranscriptionProvider instead of separate flags/strings.\n   * This allows us to handle character settings, env variables, and fallback logic.\n   */\n  private transcriptionProvider: TranscriptionProvider | null = null;\n\n  private deepgram: DeepgramClient | null = null;\n  private openai: OpenAI | null = null;\n\n  /**\n   * We keep the queue and processing logic as is.\n   */\n  private queue: {\n    audioBuffer: ArrayBuffer;\n    resolve: (result: string | null) => void;\n  }[] = [];\n  private processing: boolean = false;\n\n  private transcriptionOptions: TranscriptionOptions;\n\n  private isWhisperModelPreloaded: boolean = false;\n\n  // Track if a download is currently in progress\n  private isDownloadInProgress: boolean = false;\n\n  // Promise to track the current download process\n  private currentDownloadPromise: Promise<boolean> | null = null;\n\n  /**\n   * CHANGED: initialize() now checks:\n   * 1) character.settings.transcription (if available and keys exist),\n   * 2) then the .env TRANSCRIPTION_PROVIDER,\n   * 3) then old fallback logic (Deepgram -> OpenAI -> local).\n   */\n  async initialize(_runtime: IAgentRuntime): Promise<void> {\n    this.runtime = _runtime;\n\n    const openaiBaseURL = this.runtime.getSetting('OPENAI_API_URL');\n\n    elizaLogger.log('OPENAI_API_URL', openaiBaseURL);\n\n    // Initialize the model preload flag\n    this.isWhisperModelPreloaded = false;\n\n    // Check if the model is already downloaded\n    const modelName = this.transcriptionOptions?.localModelName ?? 'base.en';\n    const isAlreadyDownloaded = await this.isWhisperModelDownloaded(modelName);\n    if (isAlreadyDownloaded) {\n      this.isWhisperModelPreloaded = true;\n      elizaLogger.log(\n        `Whisper model ${modelName} is already downloaded and ready to use`,\n      );\n    }\n\n    // 1) Check character settings\n    let chosenProvider: TranscriptionProvider | null = null;\n    const charSetting = this.runtime.character?.settings?.transcription;\n\n    if (charSetting === TranscriptionProvider.Deepgram) {\n      const deepgramKey = this.runtime.getSetting('DEEPGRAM_API_KEY');\n      if (deepgramKey) {\n        this.deepgram = createClient(deepgramKey);\n        chosenProvider = TranscriptionProvider.Deepgram;\n      }\n    } else if (charSetting === TranscriptionProvider.OpenAI) {\n      const openaiKey = this.runtime.getSetting('OPENAI_API_KEY');\n      if (openaiKey) {\n        this.openai = new OpenAI({ apiKey: openaiKey, baseURL: openaiBaseURL });\n        chosenProvider = TranscriptionProvider.OpenAI;\n      }\n    } else if (charSetting === TranscriptionProvider.Local) {\n      chosenProvider = TranscriptionProvider.Local;\n\n      // If local transcription is chosen, preload the model\n      const modelName = this.transcriptionOptions?.localModelName ?? 'base.en';\n      this.preloadWhisperModel(modelName);\n    }\n\n    // 2) If not chosen from character, check .env\n    if (!chosenProvider) {\n      const envProvider = this.runtime.getSetting('TRANSCRIPTION_PROVIDER');\n      if (envProvider) {\n        switch (envProvider.toLowerCase()) {\n          case 'deepgram':\n            {\n              const dgKey = this.runtime.getSetting('DEEPGRAM_API_KEY');\n              if (dgKey) {\n                this.deepgram = createClient(dgKey);\n                chosenProvider = TranscriptionProvider.Deepgram;\n              }\n            }\n            break;\n          case 'openai':\n            {\n              const openaiKey = this.runtime.getSetting('OPENAI_API_KEY');\n              if (openaiKey) {\n                this.openai = new OpenAI({\n                  apiKey: openaiKey,\n                  baseURL: openaiBaseURL,\n                });\n                chosenProvider = TranscriptionProvider.OpenAI;\n              }\n            }\n            break;\n          case 'local':\n            chosenProvider = TranscriptionProvider.Local;\n            break;\n        }\n      }\n    }\n\n    // 3) If still none, fallback to old logic: Deepgram -> OpenAI -> local\n    if (!chosenProvider) {\n      const deepgramKey = this.runtime.getSetting('DEEPGRAM_API_KEY');\n      if (deepgramKey) {\n        this.deepgram = createClient(deepgramKey);\n        chosenProvider = TranscriptionProvider.Deepgram;\n      } else {\n        const openaiKey = this.runtime.getSetting('OPENAI_API_KEY');\n        if (openaiKey) {\n          this.openai = new OpenAI({\n            apiKey: openaiKey,\n            baseURL: openaiBaseURL,\n          });\n          chosenProvider = TranscriptionProvider.OpenAI;\n        } else {\n          chosenProvider = TranscriptionProvider.Local;\n\n          // If local transcription is the fallback, preload the model\n          const modelName =\n            this.transcriptionOptions?.localModelName ?? 'base.en';\n          this.preloadWhisperModel(modelName);\n        }\n      }\n    }\n\n    this.transcriptionProvider = chosenProvider;\n\n    // Leave detectCuda as is.\n    this.detectCuda();\n  }\n\n  constructor(transcriptionOptions?: TranscriptionOptions) {\n    super();\n    this.transcriptionOptions = {\n      rootDir:\n        transcriptionOptions?.rootDir ?? path.resolve(__dirname, '../../'),\n      localModelName: transcriptionOptions?.localModelName ?? 'base.en',\n    };\n    const rootDir = this.transcriptionOptions?.rootDir;\n    this.CONTENT_CACHE_DIR = path.join(rootDir, 'content_cache');\n    this.DEBUG_AUDIO_DIR = path.join(rootDir, 'debug_audio');\n    this.ensureCacheDirectoryExists();\n    this.ensureDebugDirectoryExists();\n\n    // TODO: It'd be nice to handle this more gracefully, but we can do local transcription for now\n    // TODO: remove the runtime from here, use it when called\n    // if (runtime.getSetting(\"OPENAI_API_KEY\")) {\n    //     this.openai = new OpenAI({\n    //         apiKey: runtime.getSetting(\"OPENAI_API_KEY\"),\n    //     });\n    // } else {\n    //     this.detectCuda();\n    // }\n  }\n\n  private ensureCacheDirectoryExists() {\n    if (!fs.existsSync(this.CONTENT_CACHE_DIR)) {\n      fs.mkdirSync(this.CONTENT_CACHE_DIR, { recursive: true });\n    }\n  }\n\n  private ensureDebugDirectoryExists() {\n    if (!fs.existsSync(this.DEBUG_AUDIO_DIR)) {\n      fs.mkdirSync(this.DEBUG_AUDIO_DIR, { recursive: true });\n    }\n  }\n\n  private detectCuda() {\n    const platform = os.platform();\n    if (platform === 'linux') {\n      try {\n        fs.accessSync('/usr/local/cuda/bin/nvcc', fs.constants.X_OK);\n        this.isCudaAvailable = true;\n        elizaLogger.log(\n          'CUDA detected. Transcription will use CUDA acceleration.',\n        );\n        // eslint-disable-next-line\n            } catch (_error) {\n        elizaLogger.log('CUDA not detected. Transcription will run on CPU.');\n      }\n    } else if (platform === 'win32') {\n      const cudaPath = path.join(\n        settings.CUDA_PATH ||\n          'C:\\\\Program Files\\\\NVIDIA GPU Computing Toolkit\\\\CUDA\\\\v11.0',\n        'bin',\n        'nvcc.exe',\n      );\n      if (fs.existsSync(cudaPath)) {\n        this.isCudaAvailable = true;\n        elizaLogger.log(\n          'CUDA detected. Transcription will use CUDA acceleration.',\n        );\n      } else {\n        elizaLogger.log('CUDA not detected. Transcription will run on CPU.');\n      }\n    } else {\n      elizaLogger.log(\n        'CUDA not supported on this platform. Transcription will run on CPU.',\n      );\n    }\n  }\n\n  private async convertAudio(inputBuffer: ArrayBuffer): Promise<Buffer> {\n    const inputPath = path.join(\n      this.CONTENT_CACHE_DIR,\n      `input_${Date.now()}.wav`,\n    );\n    const outputPath = path.join(\n      this.CONTENT_CACHE_DIR,\n      `output_${Date.now()}.wav`,\n    );\n\n    fs.writeFileSync(inputPath, Buffer.from(inputBuffer));\n\n    try {\n      const { stdout } = await execAsync(\n        `ffprobe -v error -show_entries stream=codec_name,sample_rate,channels -of json \"${inputPath}\"`,\n      );\n      const probeResult = JSON.parse(stdout);\n      const stream = probeResult.streams[0];\n\n      elizaLogger.log('Input audio info:', stream);\n\n      let ffmpegCommand = `ffmpeg -i \"${inputPath}\" -ar ${this.TARGET_SAMPLE_RATE} -ac 1`;\n\n      if (stream.codec_name === 'pcm_f32le') {\n        ffmpegCommand += ' -acodec pcm_s16le';\n      }\n\n      ffmpegCommand += ` \"${outputPath}\"`;\n\n      elizaLogger.log('FFmpeg command:', ffmpegCommand);\n\n      await execAsync(ffmpegCommand);\n\n      const convertedBuffer = fs.readFileSync(outputPath);\n      fs.unlinkSync(inputPath);\n      fs.unlinkSync(outputPath);\n      return convertedBuffer;\n    } catch (error) {\n      elizaLogger.error('Error converting audio:', error);\n      throw error;\n    }\n  }\n\n  private async saveDebugAudio(audioBuffer: ArrayBuffer, prefix: string) {\n    this.ensureDebugDirectoryExists();\n\n    const filename = `${prefix}_${Date.now()}.wav`;\n    const filePath = path.join(this.DEBUG_AUDIO_DIR, filename);\n\n    fs.writeFileSync(filePath, Buffer.from(audioBuffer));\n    elizaLogger.log(`Debug audio saved: ${filePath}`);\n  }\n\n  public async transcribeAttachment(\n    audioBuffer: ArrayBuffer,\n  ): Promise<string | null> {\n    return await this.transcribe(audioBuffer);\n  }\n\n  /**\n   * If the audio buffer is too short, return null. Otherwise push to queue.\n   */\n  public async transcribe(audioBuffer: ArrayBuffer): Promise<string | null> {\n    // if the audio buffer is less than .2 seconds, just return null\n    if (audioBuffer.byteLength < 0.2 * 16000) {\n      return null;\n    }\n    return new Promise((resolve) => {\n      this.queue.push({ audioBuffer, resolve });\n      if (!this.processing) {\n        this.processQueue();\n      }\n    });\n  }\n\n  public async transcribeAttachmentLocally(\n    audioBuffer: ArrayBuffer,\n  ): Promise<string | null> {\n    return this.transcribeLocally(audioBuffer);\n  }\n\n  /**\n   * CHANGED: processQueue() uses the final transcriptionProvider enum set in initialize().\n   */\n  private async processQueue(): Promise<void> {\n    // Exit if already processing or if the queue is empty\n    if (this.processing || this.queue.length === 0) return;\n    this.processing = true;\n\n    while (this.queue.length > 0) {\n      const { audioBuffer, resolve } = this.queue.shift()!;\n      let result: string | null = null;\n\n      switch (this.transcriptionProvider) {\n        case TranscriptionProvider.Deepgram:\n          result = await this.transcribeWithDeepgram(audioBuffer);\n          break;\n        case TranscriptionProvider.OpenAI:\n          result = await this.transcribeWithOpenAI(audioBuffer);\n          break;\n        default:\n          result = await this.transcribeLocally(audioBuffer);\n      }\n\n      resolve(result);\n    }\n\n    this.processing = false;\n  }\n\n  /**\n   * Original logic from main is now handled by the final fallback in initialize().\n   * We'll keep transcribeUsingDefaultLogic() if needed by other code references,\n   * but it's no longer invoked in the new flow.\n   */\n  private async transcribeUsingDefaultLogic(\n    audioBuffer: ArrayBuffer,\n  ): Promise<string | null> {\n    if (this.deepgram) {\n      return await this.transcribeWithDeepgram(audioBuffer);\n    } else if (this.openai) {\n      return await this.transcribeWithOpenAI(audioBuffer);\n    }\n    return await this.transcribeLocally(audioBuffer);\n  }\n\n  private async transcribeWithDeepgram(\n    audioBuffer: ArrayBuffer,\n  ): Promise<string | null> {\n    const buffer = Buffer.from(audioBuffer);\n    const response = await this.deepgram.listen.prerecorded.transcribeFile(\n      buffer,\n      {\n        model: 'nova-2',\n        language: 'en-US',\n        smart_format: true,\n      },\n    );\n    const result =\n      response.result.results.channels[0].alternatives[0].transcript;\n    return result;\n  }\n\n  private async transcribeWithOpenAI(\n    audioBuffer: ArrayBuffer,\n  ): Promise<string | null> {\n    elizaLogger.log('Transcribing audio with OpenAI...');\n\n    try {\n      await this.saveDebugAudio(audioBuffer, 'openai_input_original');\n\n      const arrayBuffer = new Uint8Array(audioBuffer).buffer;\n      const convertedBuffer = Buffer.from(\n        await this.convertAudio(arrayBuffer),\n      ).buffer;\n\n      await this.saveDebugAudio(convertedBuffer, 'openai_input_converted');\n\n      const file = new File([convertedBuffer], 'audio.wav', {\n        type: 'audio/wav',\n      });\n\n      const result = await this.openai!.audio.transcriptions.create({\n        model: 'whisper-1',\n        language: 'en',\n        response_format: 'text',\n        file: file,\n      });\n\n      const trimmedResult = (result as any).trim();\n      elizaLogger.log(`OpenAI speech to text result: \"${trimmedResult}\"`);\n\n      return trimmedResult;\n    } catch (error) {\n      elizaLogger.error('Error in OpenAI speech-to-text conversion:', error);\n      if (error.response) {\n        elizaLogger.error('Response data:', error.response.data);\n        elizaLogger.error('Response status:', error.response.status);\n        elizaLogger.error('Response headers:', error.response.headers);\n      } else if (error.request) {\n        elizaLogger.error('No response received:', error.request);\n      } else {\n        elizaLogger.error('Error setting up request:', error.message);\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Checks if a whisper model is already downloaded.\n   * @param modelName The name of the model to check\n   * @returns True if the model is already downloaded, false otherwise\n   */\n  private async isWhisperModelDownloaded(modelName: string): Promise<boolean> {\n    try {\n      elizaLogger.log(\n        `Checking if whisper model ${modelName} is already downloaded...`,\n      );\n\n      // Models are typically stored in ~/.cache/whisper\n      const homeDir = os.homedir();\n      const whisperCacheDir = path.join(homeDir, '.cache', 'whisper');\n\n      // Check if the model file exists\n      const modelFilename = `ggml-${modelName}.bin`;\n      const modelPath = path.join(whisperCacheDir, modelFilename);\n\n      const exists = fs.existsSync(modelPath);\n\n      if (exists) {\n        elizaLogger.log(\n          `Whisper model ${modelName} is already downloaded at ${modelPath}`,\n        );\n      } else {\n        elizaLogger.log(`Whisper model ${modelName} is not downloaded yet`);\n      }\n\n      return exists;\n    } catch (error) {\n      elizaLogger.error(\n        `Error checking if whisper model is downloaded: ${error}`,\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Downloads the whisper model explicitly before transcription.\n   * This ensures the model is available when transcription is needed.\n   */\n  private async downloadWhisperModel(modelName: string): Promise<boolean> {\n    try {\n      // First check if the model is already downloaded\n      const isDownloaded = await this.isWhisperModelDownloaded(modelName);\n      if (isDownloaded) {\n        elizaLogger.log(\n          `Whisper model ${modelName} is already downloaded, skipping download`,\n        );\n        return true;\n      }\n\n      // If a download is already in progress, don't start another one\n      if (this.isDownloadInProgress && this.currentDownloadPromise) {\n        elizaLogger.log(\n          `A download for a whisper model is already in progress, waiting for it to complete...`,\n        );\n        return await this.currentDownloadPromise;\n      }\n\n      // Mark that we're starting a download\n      this.isDownloadInProgress = true;\n\n      // Create a new promise for this download\n      this.currentDownloadPromise = (async () => {\n        try {\n          elizaLogger.log(`Explicitly downloading whisper model: ${modelName}`);\n\n          // Use the nodejs-whisper CLI to download the model\n          const { stderr } = await execAsync(\n            `npx nodejs-whisper download ${modelName}`,\n          );\n\n          if (stderr && stderr.includes('Error')) {\n            elizaLogger.error(`Error downloading whisper model: ${stderr}`);\n            return false;\n          }\n\n          elizaLogger.log(\n            `Successfully downloaded whisper model: ${modelName}`,\n          );\n          return true;\n        } catch (error) {\n          elizaLogger.error(`Failed to download whisper model: ${error}`);\n          return false;\n        } finally {\n          // Mark that the download is complete\n          this.isDownloadInProgress = false;\n        }\n      })();\n\n      // Wait for the download to complete and return the result\n      return await this.currentDownloadPromise;\n    } catch (error) {\n      elizaLogger.error(`Error in downloadWhisperModel: ${error}`);\n      this.isDownloadInProgress = false;\n      return false;\n    }\n  }\n\n  /**\n   * Public method to preload the whisper model.\n   * This can be called separately to ensure the model is downloaded before any transcription is needed.\n   */\n  public async preloadWhisperModel(\n    modelName: string = 'base.en',\n  ): Promise<boolean> {\n    elizaLogger.log(`Preloading whisper model: ${modelName}`);\n    const result = await this.downloadWhisperModel(modelName);\n\n    // Set the flag to indicate model is preloaded\n    if (result) {\n      this.isWhisperModelPreloaded = true;\n      elizaLogger.log(`Whisper model ${modelName} is now preloaded`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Local transcription with nodejs-whisper. We keep it as it was,\n   * just making sure to handle CUDA if available.\n   */\n  public async transcribeLocally(\n    audioBuffer: ArrayBuffer,\n  ): Promise<string | null> {\n    try {\n      elizaLogger.log('Transcribing audio locally...');\n\n      // Get the model name to use\n      const modelName = this.transcriptionOptions?.localModelName ?? 'base.en';\n\n      // Check if the model is already preloaded, if not, wait for it to complete\n      if (!this.isWhisperModelPreloaded) {\n        elizaLogger.log(\n          `Whisper model not yet preloaded, waiting for download to complete...`,\n        );\n\n        try {\n          // This will either start a new download or wait for an existing one\n          const downloadResult = await this.preloadWhisperModel(modelName);\n\n          if (!downloadResult) {\n            elizaLogger.error(\n              `Failed to download whisper model ${modelName}, will try fallback approach`,\n            );\n            // We'll continue with autoDownloadModelName as a fallback\n          }\n        } catch (downloadError) {\n          elizaLogger.error(\n            `Error during whisper model download: ${downloadError}`,\n          );\n          // Continue with fallback approach\n        }\n      }\n\n      await this.saveDebugAudio(audioBuffer, 'local_input_original');\n\n      const arrayBuffer = new Uint8Array(audioBuffer).buffer;\n      const convertedBuffer = Buffer.from(\n        await this.convertAudio(arrayBuffer),\n      ).buffer;\n\n      await this.saveDebugAudio(convertedBuffer, 'local_input_converted');\n\n      const tempWavFile = path.join(\n        this.CONTENT_CACHE_DIR,\n        `temp_${Date.now()}.wav`,\n      );\n\n      // Convert the ArrayBuffer to a Uint8Array which fs.writeFileSync can handle\n      const uint8Array = new Uint8Array(convertedBuffer);\n      fs.writeFileSync(tempWavFile, uint8Array);\n\n      elizaLogger.debug(`Temporary WAV file created: ${tempWavFile}`);\n\n      let output = await nodewhisper(tempWavFile, {\n        modelName: modelName,\n        autoDownloadModelName: modelName, // Keep this as fallback\n        removeWavFileAfterTranscription: false,\n        withCuda: this.isCudaAvailable,\n        whisperOptions: {\n          outputInText: true,\n          outputInVtt: false,\n          outputInSrt: false,\n          outputInCsv: false,\n          translateToEnglish: false,\n          wordTimestamps: false,\n          timestamps_length: 60,\n          // splitOnWord: true,\n        },\n      });\n\n      output = output\n        .split('\\n')\n        .map((line) => {\n          if (line.trim().startsWith('[')) {\n            const endIndex = line.indexOf(']');\n            return line.substring(endIndex + 1);\n          }\n          return line;\n        })\n        .join('\\n');\n\n      fs.unlinkSync(tempWavFile);\n\n      if (!output || output.length < 5) {\n        elizaLogger.log('Output is null or too short, returning null');\n        return null;\n      }\n      return output;\n    } catch (error) {\n      elizaLogger.error('Error in local speech-to-text conversion:', error);\n      return null;\n    }\n  }\n}\n","import { SpeechService, TranscriptionService } from './services/index.js';\n\nconst speechTTS = {\n  name: 'default',\n  description: 'Default plugin, with basic actions and evaluators',\n  services: [new SpeechService() as any, new TranscriptionService() as any],\n  actions: [],\n};\n\nexport default speechTTS;\n"],"mappings":"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","names":["elizaLogger","Service","ServiceType","modelName"]}